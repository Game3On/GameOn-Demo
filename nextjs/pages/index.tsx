import { LOCAL_CONFIG } from "@/config"
import Head from "next/head"
import { Inter } from "@next/font/google"
import { useEffect, useMemo, useState } from "react"
import {
  HttpRpcClient,
  SimpleAccountForTokensAPI,
  TokenPaymasterAPI,
} from "@aa-lib/sdk"
import {
  ERC20__factory,
  TokenPaymaster__factory,
  WETH__factory,
} from "@aa-lib/contracts"
import { Wallet, getDefaultProvider, BigNumber } from "ethers"
import {
  formatEther,
  getAddress,
  isAddress,
  isValidName,
  keccak256,
  parseEther,
} from "ethers/lib/utils"
import cx from "clsx"
import { Field, Form, Formik, FormikHelpers } from "formik"
import { useEvent } from "react-use-event-hook"

import VortexButton from "@/components/VortexButton"

import { useIsMounted } from "@/hooks/useIsMounted"
import { provider, owner, paymaster } from "@/lib/instances"

const inter = Inter({ subsets: ["latin"] })

const parseExpectedGas = (e: Error): Error => {
  // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
  const match = e.message?.match(/paid (\d+) expected (\d+)/)
  if (match != null) {
    const paid = Math.floor(parseInt(match[1]) / 1e9)
    const expected = Math.floor(parseInt(match[2]) / 1e9)
    return new Error(
      `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
        (paid / expected) * 100,
      )}%, missing ${expected - paid} `,
    )
  }
  return e
}

const {
  entryPoint,
  accountForTokenFactory,
  bundlerUrl,
  usdt,
  weth,
  wethPaymaster,
} = LOCAL_CONFIG

enum Currency {
  ethers = "ethers",
  usdt = "usdt",
}

type FormValues = {
  addressOrName: string
  amount: string
  currency: Currency
}

type Balance = {
  value: BigNumber
  formatted: string
}

type UserBalances = {
  usdt?: Balance
  weth?: Balance
  ether?: Balance
  // erc20: Balance
}

async function getBalanceOf(
  of: string,
  tokenAddress?: string,
): Promise<Balance> {
  const isEther = !tokenAddress
  const balance = isEther
    ? await provider.getBalance(of)
    : await ERC20__factory.connect(tokenAddress, provider).balanceOf(of)
  return {
    value: balance,
    formatted: formatEther(balance),
  }
}

export default function Home() {
  const [accountApi, setAccountApi] = useState<SimpleAccountForTokensAPI>()
  const [hasDeployed, setHasDeployed] = useState(false)
  const [address, setAddress] = useState<string>()
  const [balances, setBalances] = useState<UserBalances>()
  const [bundlerProvider, setBundlerProvider] = useState<HttpRpcClient>()
  const isMounted = useIsMounted()

  const updateCurrUserBalances = useEvent(async () => {
    if (!address) {
      return
    }
    const usdtBalance = await getBalanceOf(address, usdt)
    const wethBalance = await getBalanceOf(address, weth)
    const etherBalance = await getBalanceOf(address)
    setBalances({
      usdt: usdtBalance,
      weth: wethBalance,
      ether: etherBalance,
    })
  })

  useEffect(() => {
    ;(async () => {
      const deposit = await paymaster.getDeposit()
      console.log("ðŸš€ ~ file: index.tsx:125 ~ ; ~ deposit", deposit.toString())
    })()
  }, [])

  useEffect(() => {
    const paymasterAPI = new TokenPaymasterAPI(wethPaymaster)
    const newAccountApi = new SimpleAccountForTokensAPI({
      owner,
      provider,
      paymasterAPI,
      entryPointAddress: entryPoint,
      factoryAddress: accountForTokenFactory,
      token: weth,
      paymaster: wethPaymaster,
      // index
    })
    ;(async () => {
      const address = await newAccountApi.getAccountAddress()
      const isPhantom = await newAccountApi.checkAccountPhantom()
      setAccountApi(newAccountApi)
      setAddress(address)
      setHasDeployed(!isPhantom)

      await updateCurrUserBalances()

      const { chainId } = await provider.getNetwork()
      const newBundlerProvider = new HttpRpcClient(
        bundlerUrl,
        entryPoint,
        chainId,
      )
      setBundlerProvider(newBundlerProvider)
    })()
  }, [address, updateCurrUserBalances])

  const [isActivatingAccount, setIsActivatingAccount] = useState(false)
  // Activate account
  const activateAccount = async () => {
    if (!accountApi || !address || !bundlerProvider) {
      return
    }

    setIsActivatingAccount(true)

    const data = keccak256(Buffer.from("nonce()")).slice(0, 10)
    const userOp = await accountApi.createSignedUserOp({
      target: address,
      data,
    })

    try {
      const userOpHash = await bundlerProvider.sendUserOpToBundler(userOp)
      const txid = await accountApi.getUserOpReceipt(userOpHash)
      console.log("reqId", userOpHash, "txid=", txid)
      setHasDeployed(true)
    } catch (e: any) {
      throw parseExpectedGas(e)
    }
  }

  const hasAnyBalances =
    balances &&
    Object.values(balances).some((balance) => !!balance && balance.value.gt(0))

  const faucet = async (token?: "ether" | "weth" | "usdt" | "erc20") => {
    if (!address || (balances && !Object.values(balances).some((x) => !!x))) {
      throw new Error("There's no address or balances to faucet for")
    }

    const requiredBalances = balances as Required<UserBalances>

    switch (token) {
      case "ether": {
        const ownerBalance = await owner.getBalance()
        if (
          requiredBalances.ether.value.gt(parseEther("1")) &&
          ownerBalance.gt(parseEther("10000"))
        ) {
          throw "There is no need to faucet for"
        }
        await owner.sendTransaction({
          to: address,
          value: parseEther("1").sub(requiredBalances.ether.value),
          gasLimit: 1e6
        })
      }
      case "weth": {
        const ownerBalance = await getBalanceOf(address, weth)
        if (
          requiredBalances.weth.value.gt(parseEther("1")) &&
          ownerBalance.value.gt(parseEther("10000"))
        ) {
          throw "There is no need to faucet for"
        }
        await WETH__factory.connect(weth, owner).transfer(
          address,
          parseEther("1").sub(requiredBalances.weth.value),
        )
      }
      default: {
        updateCurrUserBalances()
      }
    }
  }

  const handleTransfer = async (
    { addressOrName, amount }: FormValues,
    { setSubmitting }: FormikHelpers<FormValues>,
  ) => {
    if (!accountApi || !bundlerProvider || !amount) {
      return
    }

    const isEns = isValidName(addressOrName)
    // Unchecksumed address
    const simpleAddress = isEns
      ? await provider.resolveName(addressOrName)
      : addressOrName

    const address = simpleAddress ? getAddress(simpleAddress) : null

    if (!address) {
      throw new Error("Not a resolvable ens name")
    }

    setSubmitting(true)
    // Construct transfer op and send it to bundler
    const userOp = await accountApi.createSignedUserOp({
      target: address,
      data: "0x",
      value: parseEther(amount),
    })

    try {
      const userOpHash = await bundlerProvider.sendUserOpToBundler(userOp)
      const txid = await accountApi.getUserOpReceipt(userOpHash)
      console.log("reqId", userOpHash, "txid=", txid)
      await updateCurrUserBalances()
    } catch (e: any) {
      throw parseExpectedGas(e)
    }

    setSubmitting(false)
  }

  const initialFormValues: FormValues = {
    addressOrName: "",
    amount: "0",
    currency: Currency.ethers,
  }

  return (
    <>
      <Head>
        <title>AA Lib Demo</title>
        <meta name="description" content="aa lib example" />
        <meta property="og:title" content="AA lib example" key="title" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={cx("p-24 min-h-screen text-xl")}>
        <div className="space-y-6">
          <h1
            className={cx(
              "text-5xl font-extrabold capitalize",
              inter.className,
            )}
          >
            AA Lib demo
          </h1>

          <div className="space-y-1">
            <h2
              className={cx(
                "text-3xl font-extrabold capitalize",
                inter.className,
              )}
            >
              Account State
            </h2>

            <div className="flex items-center gap-2">
              <strong>Deployed:</strong> {hasDeployed.toString()}
            </div>
            <div className="capitalize">
              <strong>Account Address:</strong> {address}
            </div>
            {/* Activation */}
            <div
              className={cx(
                isMounted && !hasDeployed ? "flex opacity-100" : "hidden",
                "none items-center gap-3 transition-all duration-300",
              )}
            >
              <strong className="capitalize text-orange-700">
                activate account by take this pill &#8594;
              </strong>
              <VortexButton
                rotate={isActivatingAccount}
                onClick={activateAccount}
              />
            </div>
          </div>
          {/* Balances */}
          {/* Demonstrate sponsor and transfer using swc api */}
          <div className="space-y-1">
            <h2 className={cx("text-3xl font-extrabold", inter.className)}>
              Balances
            </h2>
            <div className="flex gap-4 items-center">
              <strong>ETH: </strong>
              <span>{balances?.ether?.formatted}</span>

              {!!balances?.ether &&
                balances.ether.value.lt(parseEther("1")) && (
                  <button
                    className="capitalize inline-flex items-center rounded-md border border-transparent bg-pink-600 px-2 py-2 text-sm font-medium leading-4 text-white shadow-sm hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2"
                    onClick={() => faucet("ether")}
                  >
                    faucet
                  </button>
                )}
            </div>
            <div>
              <strong>USDT: </strong>
              <span>{balances?.usdt?.formatted}</span>
            </div>
            <div className="flex gap-4 items-center">
              <strong>WETH: </strong>
              <span>{balances?.weth?.formatted}</span>

              {!!balances?.weth && balances.weth.value.lt(parseEther("1")) && (
                <button
                  className="capitalize inline-flex items-center rounded-md border border-transparent bg-pink-600 px-2 py-2 text-sm font-medium leading-4 text-white shadow-sm hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2"
                  onClick={() => faucet("weth")}
                >
                  faucet
                </button>
              )}
            </div>
          </div>

          {hasAnyBalances && (
            <Formik initialValues={initialFormValues} onSubmit={handleTransfer}>
              {({
                values,
                errors,
                touched,
                isSubmitting,
                isValid,
                /* and other goodies */
              }) => (
                <div>
                  <h2
                    className={cx("text-3xl font-extrabold", inter.className)}
                  >
                    Transfer
                  </h2>
                  <Form className="mt-2 pb-2">
                    <div className="flex items-end">
                      <div className="flex flex-wrap items-center gap-2 w-full sm:max-w-4xl">
                        <label
                          htmlFor="addressOrName"
                          className="text-base font-semibold text-slate-800"
                        >
                          Transfer to
                        </label>
                        <div className="relative">
                          <Field
                            as="input"
                            type="text"
                            name="addressOrName"
                            id="addressOrName"
                            className={cx(
                              "block rounded-md sm:text-sm w-auto",
                              errors.addressOrName
                                ? "border-red-300 text-red-900 placeholder-red-300 focus:border-red-500 focus:outline-none focus:ring-red-500"
                                : "border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
                            )}
                            placeholder="0x... or vitalik.eth"
                            validate={(addressOrName: string) => {
                              if (!addressOrName) {
                                return "Address is required"
                              }
                              const notAddrOrEns =
                                !isAddress(addressOrName) &&
                                !isValidName(addressOrName)
                              const nameNotEndsWithEth =
                                !isAddress(addressOrName) &&
                                isValidName(addressOrName) &&
                                !addressOrName.endsWith(".eth")
                              if (notAddrOrEns || nameNotEndsWithEth) {
                                return "Invalid address or ens name"
                              }
                            }}
                          />
                          <div className="absolute top-11 left-1 text-sm text-red-600">
                            <p>
                              {errors.addressOrName &&
                                touched.addressOrName &&
                                errors.addressOrName}
                            </p>
                          </div>
                        </div>

                        <label
                          htmlFor="amount"
                          className="text-base font-semibold text-slate-800"
                        >
                          with
                        </label>
                        <div className="relative rounded-md shadow-sm">
                          <Field
                            as="input"
                            type="text"
                            name="amount"
                            id="amount"
                            className={cx(
                              "block rounded-md sm:text-sm w-auto",
                              errors.amount
                                ? "border-red-300 text-red-900 placeholder-red-300 focus:border-red-500 focus:outline-none focus:ring-red-500"
                                : "border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
                            )}
                            placeholder="0.00"
                          />
                          <div className="absolute inset-y-0 right-0 flex items-center">
                            <label htmlFor="currency" className="sr-only">
                              Currency
                            </label>
                            <Field
                              id="currency"
                              name="currency"
                              as="select"
                              className="h-full rounded-md border-transparent bg-transparent py-0 pl-2 pr-7 text-gray-500 sm:text-sm"
                            >
                              <option>Ethers</option>
                              <option>USDT</option>
                            </Field>
                          </div>
                        </div>

                        <button
                          type="submit"
                          disabled={
                            isSubmitting || !isValid || !values.addressOrName
                          }
                          className={cx(
                            "capitalize inline-flex w-full items-center justify-center rounded-md border border-transparent bg-blue-600 disabled:bg-gray-400 px-2 py-2 text-sm font-medium leading-4 text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
                            "sm:ml-1 sm:w-auto sm:text-sm",
                          )}
                        >
                          transfer
                        </button>
                      </div>
                    </div>
                  </Form>
                </div>
              )}
            </Formik>
          )}
        </div>
      </main>
    </>
  )
}
