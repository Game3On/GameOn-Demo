import { LOCAL_CONFIG } from "@/config"
import Head from "next/head"
import { Inter } from "@next/font/google"
import { useCallback, useEffect, useMemo, useState } from "react"
import { HttpRpcClient, SimpleAccountAPI } from "@aa-lib/sdk"
import { USDToken__factory, USDToken } from "@aa-lib/contracts"
import { Wallet, getDefaultProvider } from "ethers"
import cx from "clsx"
import { Field, Form, Formik, FormikHelpers } from "formik"

import VortexButton from "@/components/VortexButton"
import {
  formatEther,
  getAddress,
  isAddress,
  isValidName,
  keccak256,
  parseEther,
} from "ethers/lib/utils"

const inter = Inter({ subsets: ["latin"] })

const parseExpectedGas = (e: Error): Error => {
  // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
  const match = e.message?.match(/paid (\d+) expected (\d+)/)
  if (match != null) {
    const paid = Math.floor(parseInt(match[1]) / 1e9)
    const expected = Math.floor(parseInt(match[2]) / 1e9)
    return new Error(
      `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
        (paid / expected) * 100,
      )}%, missing ${expected - paid} `,
    )
  }
  return e
}

const { mnemonic, providerUrl, entryPoint, accountFactory, bundlerUrl, usdt } =
  LOCAL_CONFIG

enum Currency {
  ethers = "ethers",
  usdt = "usdt",
}

type FormValues = {
  addressOrName: string
  amount: string
  currency: Currency
}

export default function Home() {
  const [accountApi, setAccountApi] = useState<SimpleAccountAPI>()
  const [hasDeployed, setHasDeployed] = useState(false)
  const [address, setAddress] = useState<string>()
  const [USDTContract, setUSDTContract] = useState<USDToken>()
  const [usdtBalance, setUsdtBalance] = useState<string>()
  const [etherBalance, setEtherBalance] = useState<string>()
  const [bundlerProvider, setBundlerProvider] = useState<HttpRpcClient>()

  const provider = useMemo(() => getDefaultProvider(providerUrl), [])
  const owner = useMemo(
    () => Wallet.fromMnemonic(mnemonic).connect(provider),
    [provider],
  )

  // TODO: Remove set mutations
  const updateUserBalances = useCallback(
    async (address: string) => {
      const contract = await USDToken__factory.connect(usdt, owner)
      const bigBalance = await contract.balanceOf(address)
      setUsdtBalance(formatEther(bigBalance))
      const bigEtherBalance = await provider.getBalance(address)
      setEtherBalance(formatEther(bigEtherBalance))
    },
    [owner, provider],
  )

  useEffect(() => {
    const newAccountApi = new SimpleAccountAPI({
      owner,
      provider,
      entryPointAddress: entryPoint,
      factoryAddress: accountFactory,
      // index
    })
    ;(async () => {
      const address = await newAccountApi.getAccountAddress()
      const isPhantom = await newAccountApi.checkAccountPhantom()
      setAccountApi(newAccountApi)
      setAddress(address)
      setHasDeployed(!isPhantom)

      await updateUserBalances(address)

      const { chainId } = await provider.getNetwork()
      const newBundlerProvider = new HttpRpcClient(
        bundlerUrl,
        entryPoint,
        chainId,
      )
      setBundlerProvider(newBundlerProvider)
    })()
  }, [address, updateUserBalances, owner, provider])

  const [isActivatingAccount, setIsActivatingAccount] = useState(false)
  // Activate account
  const activateAccount = async () => {
    if (!accountApi || !address || !bundlerProvider) {
      return
    }

    setIsActivatingAccount(true)

    const data = keccak256(Buffer.from("nonce()")).slice(0, 10)
    const userOp = await accountApi.createSignedUserOp({
      target: address,
      data,
    })

    try {
      const userOpHash = await bundlerProvider.sendUserOpToBundler(userOp)
      const txid = await accountApi.getUserOpReceipt(userOpHash)
      console.log("reqId", userOpHash, "txid=", txid)
      setHasDeployed(true)
    } catch (e: any) {
      throw parseExpectedGas(e)
    }
  }

  const faucet = async () => {
    if (!etherBalance || !address) {
      return
    }

    const ownerBalance = await owner.getBalance()
    const accountBalance = parseEther(etherBalance)

    if (
      accountBalance.gt(parseEther("1")) &&
      ownerBalance.gt(parseEther("10000"))
    ) {
      throw "There is no need to faucet for"
    }

    await owner.sendTransaction({
      to: address,
      value: parseEther("1").sub(accountBalance),
    })
    updateUserBalances(address)
  }

  const handleTransfer = async (
    { addressOrName, amount, currency }: FormValues,
    { setSubmitting }: FormikHelpers<FormValues>,
  ) => {
    if (!accountApi || !bundlerProvider || !amount) {
      return
    }

    const isEns = isValidName(addressOrName)
    // Unchecksumed address
    const simpleAddress = isEns
      ? await provider.resolveName(addressOrName)
      : addressOrName

    const address = simpleAddress ? getAddress(simpleAddress) : null

    if (!address) {
      throw new Error("Not a resolvable ens name")
    }

    setSubmitting(true)
    // Construct transfer op and send it to bundler
    const userOp = await accountApi.createSignedUserOp({
      target: address,
      data: "0x",
      value: parseEther(amount),
    })

    try {
      const userOpHash = await bundlerProvider.sendUserOpToBundler(userOp)
      const txid = await accountApi.getUserOpReceipt(userOpHash)
      console.log("reqId", userOpHash, "txid=", txid)
      await updateUserBalances(address)
    } catch (e: any) {
      throw parseExpectedGas(e)
    }

    setSubmitting(false)
  }

  const initialFormValues: FormValues = {
    addressOrName: "",
    amount: '0',
    currency: Currency.ethers,
  }

  return (
    <>
      <Head>
        <title>AA Lib Demo</title>
        <meta name="description" content="aa lib example" />
        <meta property="og:title" content="AA lib example" key="title" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className={cx("p-24 min-h-screen text-xl")}>
        <div className="space-y-6">
          <h1
            className={cx(
              "text-5xl font-extrabold capitalize",
              inter.className,
            )}
          >
            AA Lib demo
          </h1>

          <div className="space-y-1">
            <h2
              className={cx(
                "text-3xl font-extrabold capitalize",
                inter.className,
              )}
            >
              Account State
            </h2>

            <div className="flex items-center gap-2">
              <strong>Deployed:</strong> {hasDeployed.toString()}
            </div>
            <div className="capitalize">
              <strong>Account Address:</strong> {address}
            </div>
            <div
              className={cx(
                hasDeployed ? "hidden" : "flex opacity-100",
                "none items-center gap-3 transition-all duration-300",
              )}
            >
              <strong className="capitalize text-orange-700">
                activate account by take this pill &#8594;
              </strong>
              <VortexButton
                rotate={isActivatingAccount}
                onClick={activateAccount}
              />
            </div>
          </div>
          {/* Balances */}
          {/* Demonstrate sponsor and transfer using swc api */}
          <div className="space-y-1">
            <h2 className={cx("text-3xl font-extrabold", inter.className)}>
              Balances
            </h2>
            <div className="flex gap-4 items-center">
              <strong>ETH: </strong>
              <span>{etherBalance}</span>

              {!!etherBalance && parseEther(etherBalance).lt(1) && (
                <button
                  className="capitalize inline-flex items-center rounded-md border border-transparent bg-pink-600 px-2 py-2 text-sm font-medium leading-4 text-white shadow-sm hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2"
                  onClick={() => faucet()}
                >
                  faucet
                </button>
              )}
            </div>
            <div>
              <strong>USDT: </strong>
              <span>{usdtBalance}</span>
            </div>
          </div>

          {!!etherBalance && parseEther(etherBalance).gt(0) && (
            <Formik initialValues={initialFormValues} onSubmit={handleTransfer}>
              {({
                values,
                errors,
                touched,
                isSubmitting,
                isValid,
                /* and other goodies */
              }) => (
                <div>
                  <h2
                    className={cx("text-3xl font-extrabold", inter.className)}
                  >
                    Transfer
                  </h2>
                  <Form className="mt-2 pb-2">
                    <div className="flex items-end">
                      <div className="flex flex-wrap items-center gap-2 w-full sm:max-w-4xl">
                        <label
                          htmlFor="addressOrName"
                          className="text-base font-semibold text-slate-800"
                        >
                          Transfer to
                        </label>
                        <div className="relative">
                          <Field
                            as="input"
                            type="text"
                            name="addressOrName"
                            id="addressOrName"
                            className={cx(
                              "block rounded-md sm:text-sm w-auto",
                              errors.addressOrName
                                ? "border-red-300 text-red-900 placeholder-red-300 focus:border-red-500 focus:outline-none focus:ring-red-500"
                                : "border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
                            )}
                            placeholder="0x... or vitalik.eth"
                            validate={(addressOrName: string) => {
                              if (!addressOrName) {
                                return "Address is required"
                              }
                              const notAddrOrEns =
                                !isAddress(addressOrName) &&
                                !isValidName(addressOrName)
                              const nameNotEndsWithEth =
                                !isAddress(addressOrName) &&
                                isValidName(addressOrName) &&
                                !addressOrName.endsWith(".eth")
                              if (notAddrOrEns || nameNotEndsWithEth) {
                                return "Invalid address or ens name"
                              }
                            }}
                          />
                          <div className="absolute top-11 left-1 text-sm text-red-600">
                            <p>
                              {errors.addressOrName &&
                                touched.addressOrName &&
                                errors.addressOrName}
                            </p>
                          </div>
                        </div>

                        <label
                          htmlFor="amount"
                          className="text-base font-semibold text-slate-800"
                        >
                          with
                        </label>
                        <div className="relative rounded-md shadow-sm">
                          <Field
                            as="input"
                            type="text"
                            name="amount"
                            id="amount"
                            className={cx(
                              "block rounded-md sm:text-sm w-auto",
                              errors.amount
                                ? "border-red-300 text-red-900 placeholder-red-300 focus:border-red-500 focus:outline-none focus:ring-red-500"
                                : "border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500",
                            )}
                            placeholder="0.00"
                          />
                          <div className="absolute inset-y-0 right-0 flex items-center">
                            <label htmlFor="currency" className="sr-only">
                              Currency
                            </label>
                            <Field
                              id="currency"
                              name="currency"
                              as="select"
                              className="h-full rounded-md border-transparent bg-transparent py-0 pl-2 pr-7 text-gray-500 sm:text-sm"
                            >
                              <option>Ethers</option>
                              <option>USDT</option>
                            </Field>
                          </div>
                        </div>

                        <button
                          type="submit"
                          disabled={
                            isSubmitting || !isValid || !values.addressOrName
                          }
                          className={cx(
                            "capitalize inline-flex w-full items-center justify-center rounded-md border border-transparent bg-blue-600 disabled:bg-gray-400 px-2 py-2 text-sm font-medium leading-4 text-white shadow-sm hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2",
                            "sm:ml-1 sm:w-auto sm:text-sm",
                          )}
                        >
                          transfer
                        </button>
                      </div>
                    </div>
                  </Form>
                </div>
              )}
            </Formik>
          )}
        </div>
      </main>
    </>
  )
}
