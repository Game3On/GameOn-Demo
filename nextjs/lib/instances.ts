import { LOCAL_CONFIG } from "@/config"
import { FixedPaymaster__factory, USDPaymaster__factory, VerifyingPaymaster__factory, WETHPaymaster__factory } from "@aa-lib/contracts"
import { getDefaultProvider, Signer, Wallet } from "ethers"
import { JsonRpcProvider } from '@ethersproject/providers'
import { parseEther } from "ethers/lib/utils.js"
import { ERC4337EthersProvider, TokenPaymasterAPI, VerifiedPaymasterAPI, ClientConfig, wrapSimpleProvider, wrapPaymasterProvider } from "@aa-lib/sdk"

const {
  mnemonic,
  providerUrl,
  bundlerUrl,
  entryPoint,
  accountFactory,
  accountForTokenFactory,
  usdt,
  weth,
  tokenAddr,
  wethPaymaster,
  usdtPaymaster,
  fixedPaymaster,
  gaslessPaymaster
} = LOCAL_CONFIG

export const provider = getDefaultProvider(providerUrl) as JsonRpcProvider
export const admin = Wallet.fromMnemonic(mnemonic).connect(provider)
console.log("signer", admin.address);

export enum PMMode {
    none = "",
    weth = "weth",
    usdt = "usdt",
    token = "token",
    gasless = "gasless"
} 

export enum Currency {
    ether = "ether",
    weth = "weth",
    usdt = "usdt",
    token = "token"
}

export const parseExpectedGas = (e: Error): Error => {
  // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
  const match = e.message?.match(/paid (\d+) expected (\d+)/)
  if (match != null) {
    const paid = Math.floor(parseInt(match[1]) / 1e9)
    const expected = Math.floor(parseInt(match[2]) / 1e9)
    return new Error(
      `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
        (paid / expected) * 100,
      )}%, missing ${expected - paid} `,
    )
  }
  return e
}

export async function getAAProvider(pmMode?: PMMode, owner?: Signer): Promise<ERC4337EthersProvider> {
    let config: ClientConfig
    let paymasterAPI: TokenPaymasterAPI
    if (!owner) throw new Error("No owner")
    if (!pmMode) pmMode = PMMode.none
    switch (pmMode) {
        case PMMode.none:
          config = {
            entryPointAddress: entryPoint,
            bundlerUrl: bundlerUrl,
            accountFacotry: accountFactory
          }
          console.log("own provider", config);
          return await wrapSimpleProvider(provider, config, owner)
        case PMMode.weth:
          paymasterAPI = new TokenPaymasterAPI(wethPaymaster)
          config = {
            entryPointAddress: entryPoint,
            bundlerUrl: bundlerUrl,
            accountFacotry: accountForTokenFactory,
            paymasterAPI
          }
          console.log("weth provider", config);
          return await wrapPaymasterProvider(provider, config, owner, weth, wethPaymaster)
        case PMMode.usdt:
          paymasterAPI = new TokenPaymasterAPI(usdtPaymaster)
          config = {
            entryPointAddress: entryPoint,
            bundlerUrl: bundlerUrl,
            accountFacotry: accountForTokenFactory,
            paymasterAPI
          }
          console.log("usdt provider", config);
          return await wrapPaymasterProvider(provider, config, owner, usdt, usdtPaymaster)
        case PMMode.token:
          paymasterAPI = new TokenPaymasterAPI(fixedPaymaster)
          config = {
            entryPointAddress: entryPoint,
            bundlerUrl: bundlerUrl,
            accountFacotry: accountForTokenFactory,
            paymasterAPI
          }
          console.log("token provider", config);
          return await wrapPaymasterProvider(provider, config, owner, tokenAddr, fixedPaymaster)
        case PMMode.gasless:
          paymasterAPI = new VerifiedPaymasterAPI(gaslessPaymaster, owner)
          config = {
            entryPointAddress: entryPoint,
            bundlerUrl: bundlerUrl,
            accountFacotry: accountFactory,
            paymasterAPI
          }
          console.log("gasless provider", config);
          return await wrapSimpleProvider(provider, config, owner)
        default:
            throw new Error("Not implemented")
        }

}

export async function deposit(pmMode?: PMMode, amount?: string) {
    if (!pmMode || !amount) throw new Error("No pmMode or amount")
    switch (pmMode) {
        case PMMode.weth: {
          const paymaster = WETHPaymaster__factory.connect(wethPaymaster, admin)
          await paymaster.deposit({ value: parseEther(amount) })
          break
        } 
        case PMMode.usdt: {
          const paymaster = USDPaymaster__factory.connect(usdtPaymaster, admin)
          await paymaster.deposit({ value: parseEther(amount) })
          break
        }
        case PMMode.token: {
          const paymaster = FixedPaymaster__factory.connect(fixedPaymaster, admin)
          await paymaster.deposit({ value: parseEther(amount) })
          break
        }
        case PMMode.gasless: {
          const paymaster = VerifyingPaymaster__factory.connect(gaslessPaymaster, admin)
          await paymaster.deposit({ value: parseEther(amount) })
          break
        }
        default:
            throw new Error("Not implemented")
    }
}

export async function getDeposit(pmMode: PMMode) {
  switch (pmMode) {
    case PMMode.weth: {
      const paymaster = WETHPaymaster__factory.connect(wethPaymaster, admin)
      return paymaster.getDeposit()
    } 
    case PMMode.usdt: {
      const paymaster = USDPaymaster__factory.connect(usdtPaymaster, admin)
      return paymaster.getDeposit()
    }
    case PMMode.token: {
      const paymaster = FixedPaymaster__factory.connect(fixedPaymaster, admin)
      return paymaster.getDeposit()
    }
    case PMMode.gasless: {
      const paymaster = VerifyingPaymaster__factory.connect(gaslessPaymaster, admin)
      return paymaster.getDeposit()
    }
    default:
        throw new Error("Not implemented")
}
}

export type FormValues = {
  target: string
  amount: string
  currency: Currency
}


